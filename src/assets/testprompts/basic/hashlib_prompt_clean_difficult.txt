#!/usr/bin/env python3

# author: greyshell

import binascii
import hashlib
import bcrypt
import hmac
from base64 import b64decode
import scrypt

from colorama import Fore


def calculate_file_hash(f_name):
    """
    calculate hash of a given file
    :param f_name:
    :return:
    """
    BLOCK_SIZE = 65536  # The size of each read from the file
    file_hash = hashlib.sha512()  # create the hash object, algo used sha512
    with open(f_name, 'rb') as file:  # open the file to read it's bytes
        fb = file.read(BLOCK_SIZE)  # read from the file. take in the amount declared in BLOCK_SIZE
        while len(fb) > 0:  # while there is still data being read from the file
            file_hash.update(fb)  # update the hash
            fb = file.read(BLOCK_SIZE)  # read the next block from the file

    return file_hash.hexdigest()  # return the the hexadecimal digest of the hash


def demo_hashlib():
    """
    understanding hashlib functions
    :return:
    """
    print(Fore.MAGENTA, f"[+] usage of hashlib library:")
    print(Fore.WHITE)
    print(Fore.CYAN, f"algorithms available: ")
    # hashlib.algorithms_available -> returns a set, use list() to convert it to a list

    print(hashlib.algorithms_available)
    print(Fore.MAGENTA)

    message = 'secret'

    list_of_hash = ['ripemd160', 'sha1', 'sha256', 'sha512', 'sha3_256', 'sha3_512', 'blake2b',
                    'blake2s']

    for h in list_of_hash:
        result = hashlib.new(h, message.encode()).hexdigest()
        print(f"{h} => {result}")

    print(Fore.WHITE)
    # alternate method: efficient and faster than new()
    result = hashlib.sha512(message.encode()).hexdigest()
    print(Fore.BLUE, f"sha512_256 using constructor  => {result}")

    # variable length digest
    print(Fore.WHITE)
    result = hashlib.shake_256(message.encode()).hexdigest(32)
    print(Fore.BLUE, f"shake_256 => {result}")

    # key derivation and stretching
    print(Fore.WHITE)
    dk = hashlib.pbkdf2_hmac(hmac.sha256, message.encode(), b'password',